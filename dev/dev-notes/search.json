[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "BMM Developer Notes",
    "section": "",
    "text": "Overview\nThis article aims to help developers contribute new models to bmm. It is a work in progress and will be updated as the package evolves. It explains how to set-up your system for package development, the structure of the package, and the workflow for contributing new models to the package.\nWe follow a github flow workflow. The repository contains two main branches:\n\nMaster (contains the latest released stable version of the bmm package)\nDevelop (contains the latest stable development branch)\n\nAll new feature development should occur on an independent branch from Develop. If you want to contribute a new model to the bmm package, you need to fork the repository, create a new branch for your model, extensively test the model, and eventually submit a pull request for your changes to be merged into the Develop branch of the main repository. Your changes will be reviewed by someone from the core team. Once your changes are merged into the Develop branch, they will be included in the next release of the package."
  },
  {
    "objectID": "setup.html",
    "href": "setup.html",
    "title": "1  System setup",
    "section": "",
    "text": "1.1 Setting up a local fork of the bmm repository",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>System setup</span>"
    ]
  },
  {
    "objectID": "setup.html#setting-up-a-local-fork-of-the-bmm-repository",
    "href": "setup.html#setting-up-a-local-fork-of-the-bmm-repository",
    "title": "1  System setup",
    "section": "1.1 Setting up a local fork of the bmm repository",
    "text": "1.1 Setting up a local fork of the bmm repository\n\nFork the bmm github repository. This will create a copy of the current development branch into your own github account\n\nClone your fork to your local machine\nCreate a new branch for your model, typically named feature/name-of-my-model"
  },
  {
    "objectID": "setup.html#package-development-via-rstudio-and-devtools",
    "href": "setup.html#package-development-via-rstudio-and-devtools",
    "title": "1  System setup",
    "section": "1.2 Package development via RStudio and devtools",
    "text": "1.2 Package development via RStudio and devtools\nThe bmm package is setup as an RStudio project. Opening the bmm.Rproj file will open a new RStudio instance, which facilitates package development with a few commands from the devtools package. A great tutorial on package development can be found here. Below is a summary of the most important steps\n\nMake sure you have the devtools package and a few others installed and loaded\ninstall.packages(c(\"devtools\", \"roxygen2\", \"testthat\", \"knitr\"))\nlibrary(devtools)\nTo avoid having to load the package every time, you can add the following code to your .Rprofile file\nif (interactive()) {\n  suppressMessages(require(devtools))\n}\nAs noted here, you can create and open an .Rprofile file, if you don’t already have one with\nuse_devtools()\nLoad the current version of the bmm package based on your local files\nload_all()  # or ctrl+shift+L\nyou can use this command whenever you make changes to the package code to see the changes in action. You should not call library(bmm) or source the files manually, as this will load the installed version of the package, not the one you are developing.\nMake any changes to the package code that you need to make (elaborated in the next section)\nUse check() to check the package for errors and warnings\ncheck()\nyou should always ensure that check() produces no errors before submitting a pull request\nUse document() to update the documentation\ndocument()"
  },
  {
    "objectID": "git-workflow.html",
    "href": "git-workflow.html",
    "title": "2  Git and Github workflow",
    "section": "",
    "text": "2.1 Git commands\nAdd your changes to git, commit them and then push your changes to your forked repository. You can run these commands from a terminal or from the RStudio terminal (with the project working directory)\nAdd all changed files to the staging area:\nCommit the changes to the local repository\nPush the changes to your forked repository\nYou can (and should) repeat this process as many times as you need to before submitting a pull request. This will allow you to make many small changes and test them before submitting a pull request. Ideally each commit should be a small, self-contained change that can be easily reviewed.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Git and Github workflow</span>"
    ]
  },
  {
    "objectID": "git-workflow.html#git-commands",
    "href": "git-workflow.html#git-commands",
    "title": "2  Git and Github workflow",
    "section": "2.1 Git commands",
    "text": "2.1 Git commands\nAdd your changes to git, commit them and then push your changes to your forked repository. You can run these commands from a terminal or from the RStudio terminal (with the project working directory)\nAdd all changed files to the staging area:\ngit add *  \nCommit the changes to the local repository\ngit commit -m \"A short message describing the changes you made\"\nPush the changes to your forked repository\ngit push\nYou can (and should) repeat this process as many times as you need to before submitting a pull request. This will allow you to make many small changes and test them before submitting a pull request. Ideally each commit should be a small, self-contained change that can be easily reviewed."
  },
  {
    "objectID": "git-workflow.html#pull-requests",
    "href": "git-workflow.html#pull-requests",
    "title": "2  Git and Github workflow",
    "section": "2.2 Pull requests",
    "text": "2.2 Pull requests\nWhen you are ready you can open a pull request from your forked repository to the main bmm repository. You can do this from the github website. Make sure to select the Develop branch as the base branch and your feature branch as the compare branch. You should add a detailed description of your changes, including the motivation for the changes and any relevant context. You should also mention any issues that your pull request resolves."
  },
  {
    "objectID": "bmm-architecture.html",
    "href": "bmm-architecture.html",
    "title": "3  BMM code structure",
    "section": "",
    "text": "3.1 The main workhorse - fit_model()\nThe main function for fitting models is fit_model(). This function is the main entry point for users to fit models. It is set-up to be independent of the specific models that are implemented in the package:\nIt calls several subroutines, implemented as generic S3 methods, to:",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>BMM code structure</span>"
    ]
  },
  {
    "objectID": "bmm-architecture.html#the-main-workhorse---fit_model",
    "href": "bmm-architecture.html#the-main-workhorse---fit_model",
    "title": "3  BMM code structure",
    "section": "3.1 The main workhorse - fit_model()",
    "text": "3.1 The main workhorse - fit_model()\nThe main function for fitting models is fit_model(). This function is the main entry point for users to fit models. It is set-up to be independent of the specific models that are implemented in the package:\nfit_model &lt;- function(formula, data, model, parallel = FALSE, \n                      chains = 4, prior = NULL, ...) {\n  # enable parallel sampling if parallel equals TRUE\n  opts &lt;- configure_options(nlist(parallel, chains, silent))\n\n  # check model, formula and data, and transform data if necessary\n  model &lt;- check_model(model)\n  formula &lt;- check_formula(model, formula)\n  data &lt;- check_data(model, data, formula)\n\n  # generate the model specification to pass to brms later\n  config_args &lt;- configure_model(model, data, formula)\n\n  # combine the default prior plus user given prior\n  config_args$prior &lt;- combine_prior(config_args$prior, prior)\n\n  # estimate the model\n  dots &lt;- list(...)\n  fit_args &lt;- combine_args(nlist(config_args, opts, dots))\n  fit &lt;- call_brm(fit_args)\n\n  # model postprocessing\n  fit &lt;- postprocess_brm(model, fit)\n\n  return(fit)\n}\nIt calls several subroutines, implemented as generic S3 methods, to:\n\nconfigure_options() - to configure local options for fitting, such as parallel sampling,\ncheck_model() - check if the model exists\ncheck_formula() - check if the formula is specified correctly\ncheck_data() - check whether the data contains all necessary information\nconfigure_model() - configures the model called for fitting\ncombine_priors() - combines the user specified priors with default priors provided for each model\ncall_brm() - fit the model using the brm() function from the brms package\npostprocess_brm() - to post-process the fitted model"
  },
  {
    "objectID": "bmm-architecture.html#models",
    "href": "bmm-architecture.html#models",
    "title": "3  BMM code structure",
    "section": "3.2 Models",
    "text": "3.2 Models\nAll models in the package are defined as S3 classes and follow a strict template. This allows us to implement general methods for handling model fitting, data checking, and post-processing. Each model has an internal function that defines the model and its parameters, and a user-facing alias. For a complete example model file and an explanation, see Section 4. The general model template looks like this:\n.model_myNewModel &lt;- function(resp_var1, required_arg1, required_arg2, ...) {\n   out &lt;- list(\n      resp_vars = nlist(resp_var1),\n      other_vars = nlist(required_arg1, required_arg2),\n      info = list(\n         domain = '',\n         task = '',\n         name = '',\n         citation = '',\n         version = '',\n         requirements = '',\n         parameters = list(),\n         fixed_parameters = list()\n      ),\n      void_mu = FALSE\n   )\n   class(out) &lt;- c('bmmmodel', 'myNewModel')\n   out\n}\nEach model is accompanied by a user-facing alias, the documentation of which is generated automatically based on the info list in the model definition.\n# user facing alias\n# information in the title and details sections will be filled in\n# automatically based on the information in the .model_modelname()$info\n#' @title `r .model_myNewModel()$info$name`\n#' @name Model Name#' @details `r model_info(myNewModel(NA,NA))`\n#' @param resp_var1 A description of the response variable\n#' @param required_arg1 A description of the required argument\n#' @param required_arg2 A description of the required argument\n#' @param ... used internally for testing, ignore it\n#' @return An object of class `bmmmodel`\n#' @export\n#' @examples\n#' \\dontrun{\n#' # put a full example here (see 'R/bmm_model_mixture3p.R' for an example)\n#' }\nmyNewModel &lt;- .model_myNewModel\nThen users can fit the model using the fit_model() function, and the model will be automatically recognized and handled by the package:\nfit &lt;- fit_model(formula, \n                 data = mydata, \n                 model = modelname(resp_var1, required_arg1, required_arg2))"
  },
  {
    "objectID": "bmm-architecture.html#s3-methods",
    "href": "bmm-architecture.html#s3-methods",
    "title": "3  BMM code structure",
    "section": "3.3 S3 methods",
    "text": "3.3 S3 methods\nThe package uses S3 methods to handle different models. This means that the same function can behave differently depending on the class of the object it is called with. For example, the configure_model(model) function called by fit_model(), is generally defined as:\nconfigure_model &lt;- function(model) {\n   UseMethod('configure_model')\n}\nand it will call a function configure_model.modelname() that is specified for each model. The same is true for other functions, such as check_data(), postprocess_brm(), and check_formula(). This allows us to add new models without having to edit the main fitting function, fit_model()."
  },
  {
    "objectID": "bmm-architecture.html#file-organization",
    "href": "bmm-architecture.html#file-organization",
    "title": "3  BMM code structure",
    "section": "3.4 File organization",
    "text": "3.4 File organization\nThe bmm package is organized into several files. The main files are:\n\nR/fit_model.R\nIt contains the main function for fitting models, fit_model(). This function is the main entry point for users to fit models. It is set-up to be independent of the specific models that are implemented in the package.\nTo add new models, you do not have to edit this file. The functions above are generic S3 methods, and they will automatically recognize new models if you add appropriate methods for them (see section Adding new models).\n\n\nR/helpers-*.R\nR/helpers-data.R, R/helpers-postprocess.R, R/helpers-model.R, R/helpers-formula.R and R/helpers-prior.R\nThese files define the main generic S3 methods for checking data, postprocessing the fitted model, configuring the model, checking the model formula, and combining priors. They contain the default methods for these functions, which are called by fit_model() if no specific method is defined for a model. If you want to add a new model, you will need to add specific methods for these functions for your model. You do not need to edit these files to add a new model.\n\n\nR/bmm_model_*.R\nEach model and it’s methods is defined in a separate file. For example, the 3-parameter mixture model is defined in bmm_model_mixture3p.R. This file contains the internal function that defines the model and its parameters, and the specific methods for the generic S3 functions. Your new model will exist in a file like this. The name of the file should be bmm_model_name_of_your_model.R. You don’t have to add this file manually - see section Adding new models.\n\n\nR/bmm_distributions.R\nThis file contains the definition of the custom distributions that are used in the package. It specifies the density, random number generation, and probability functions for the custom distributions. If your model requires a custom distribution, you will need to add it to this file. These are not used during model fitting, but can be used to generate data from the model, and to plot the model fit.\n\n\nR/utils.R, R/brms-misc.R\nVarious utility functions.\n\n\ninst/stan_chunks/\nThis directory contains the Stan chunks that are passed to the brms::stanvar() function. These are used to define the custom distributions that are used in the package. If you add a new custom distribution, you will need to add a new Stan chunk to this directory. Each model has several files, one for each corresponding stanvar block."
  },
  {
    "objectID": "example-model.html",
    "href": "example-model.html",
    "title": "4  Example model file",
    "section": "",
    "text": "4.1 The Interference Measurement Model (IMM)\nThe model is defined in the file R/bmm_model_IMM.R. Let’s go through the different parts.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Example model file</span>"
    ]
  },
  {
    "objectID": "example-model.html#the-interference-measurement-model-imm",
    "href": "example-model.html#the-interference-measurement-model-imm",
    "title": "4  Example model file",
    "section": "4.1 The Interference Measurement Model (IMM)",
    "text": "4.1 The Interference Measurement Model (IMM)\nThe model is defined in the file R/bmm_model_IMM.R. Let’s go through the different parts.\n\n4.1.1 Model definition\nThe full IMM model is defined in the following internal model class:\n.model_IMMfull &lt;- function(resp_err,  nt_features, nt_distance, setsize, ...) {\n  out &lt;- list(\n    resp_vars = nlist(resp_err),\n    other_vars = nlist(nt_features, nt_distance, setsize),\n    info = list(\n      domain = \"Visual working memory\",\n      task = \"Continuous reproduction\",\n      name = \"Interference measurement model by Oberauer and Lin (2017).\",\n      version = \"full\",\n      citation = paste0(\"Oberauer, K., & Lin, H.Y. (2017). An interference model \",\n                        \"of visual working memory. Psychological Review, 124(1), 21-59\"),\n      requirements = paste0('- The response vairable should be in radians and ',\n                            'represent the angular error relative to the target\\n  ',\n                            '- The non-target features should be in radians and be ',\n                            'centered relative to the target'),\n      parameters = list(\n        mu1 = paste0(\"Location parameter of the von Mises distribution for memory responses\",\n                     \"(in radians). Fixed internally to 0 by default.\"),\n        kappa = \"Concentration parameter of the von Mises distribution (log scale)\",\n        a = \"General activation of memory items\",\n        c = \"Context activation\",\n        s = \"Spatial similarity gradient\"\n      ),\n      fixed_parameters = list(\n        mu1 = 0\n      )),\n    void_mu = FALSE\n  )\n  class(out) &lt;- c(\"bmmmodel\",\"vwm\",\"nontargets\",\"IMMspatial\",\"IMMfull\")\n  out\n}\nHere is a brief explanation of the different components of the model definition:\nresp_vars: a list of response variables that the model will be fitted to. These variables will be used to construct the brmsformula passed to brms together with the bmmformula and the parameters of the model. The user has to provide these variables in the data frame that is passed to the fit_model function\nother_vars: a list of additional variables that are required for the model. This is used to check if the data contains all necessary information for fitting the model. In the example above, the IMM model requires the names of the variables specifying the non-target features relative to the target, the variables specifying the distance of the non-targets to the target, and the setsize. The user has to provide these variables in the data frame that is passed to the fit_model function\ninfo: contains information about the model, such as the domain, task, name, citation, version, requirements, and parameters. This information is used to check if the bmmformula contains linear model formulas for all model parameters, and also specify defaults for fixed_parameters. In addition, the info is used to generate the documentation for the model.\nvoid_mu: For models using a custom family that do not contain a location or mu parameter, for example the diffusion model, we recommend setting up a void_mu parameter. This avoids arbitrarily using one of the model parameters as the mu parameter.\nclass: is the most important part. It contains the class of the model. This is used by generic S3 methods to perform data checks and model configuration. The classes should be ordered from most general to most specific. A general class exists when the same operations can be performed on multiple models. For example, the ‘3p’, ‘IMMabc’, ‘IMMbsc’ and ‘IMMfull’ models all have non-targets and setsize arguments, so the same data checks can be performed on all of them, represented by the class nontargets. The first class should always be bmmmodel, which is the main class for all models. The last class should be the specific model name, in this case IMMfull.\n\n\n4.1.2 Model alias\nThe model alias is a user-facing function that calls the internal model function. It is defined as follows:\n# user facing alias\n\n#' @title `r .model_IMMfull(NA, NA, NA, NA)$info$name`\n#' @name IMM\n#' @details `r model_info(IMMfull(NA, NA, NA, NA), components =c('domain', 'task', 'name', 'citation'))`\n#' #### Version: `IMMfull`\n#' `r model_info(IMMfull(NA, NA, NA, NA), components =c('requirements', 'parameters'))`\n#' #### Version: `IMMbsc`\n#' `r model_info(IMMbsc(NA, NA, NA, NA), components =c('requirements', 'parameters'))`\n#' #### Version: `IMMabc`\n#' `r model_info(IMMabc(NA, NA, NA), components =c('requirements', 'parameters'))`\n#'\n#' Additionally, all IMM models have an internal parameter that is fixed to 0 to\n#' allow the model to be identifiable. This parameter is not estimated and is not\n#' included in the model formula. The parameter is:\n#'\n#'   - b = \"Background activation (internally fixed to 0)\"\n#'\n#' @param resp_err The name of the variable in the provided dataset containing the\n#'   response error. The response Error should code the response relative to the to-be-recalled\n#'   target in radians. You can transform the response error in degrees to radian using the `deg2rad` function.\n#' @param nt_features A character vector with the names of the non-target variables.\n#'   The non_target variables should be in radians and be centered relative to the\n#'   target.\n#' @param nt_distance A vector of names of the columns containing the distances of\n#'   non-target items to the target item. Only necessary for the `IMMbsc` and `IMMfull` models\n#' @param setsize Name of the column containing the set size variable (if\n#'   setsize varies) or a numeric value for the setsize, if the setsize is\n#'   fixed.\n#' @param ... used internally for testing, ignore it\n#' @return An object of class `bmmmodel`\n#' @keywords bmmmodel\n#' @export\nIMMfull &lt;- .model_IMMfull\n\n#' @rdname IMM\n#' @keywords bmmmodel\n#' @export\nIMMbsc &lt;- .model_IMMbsc\n\n#' @rdname IMM\n#' @keywords bmmmodel\n#' @export\nIMMabc &lt;- .model_IMMabc\nThe details will be filled out automatically from the model definition. The example for the IMM model also includes the aliases for the other versions of the IMM model, which are IMMbsc and IMMabc, and does some fancy formatting to include documentation about all versions of the model in the same help file.\n\n\n4.1.3 check_data() methods\nEach model should have a check_data.modelname() method that checks if the data contains all necessary information for fitting the model. For the IMM, all three versions of the model share the same data requirements, so check_data is defined for the more general class, IMMspatial. The method is defined as follows:\ncheck_data.IMMspatial &lt;- function(model, data, formula) {\n  nt_distance &lt;- model$other_vars$nt_distance\n  max_setsize &lt;- attr(data, 'max_setsize')\n\n  if (length(nt_distance) &lt; max_setsize - 1) {\n    stop(paste0(\"The number of columns for spatial positions in the argument \",\n                \"'nt_distance' is less than max(setsize)-1\"))\n  } else if (length(nt_distance) &gt; max_setsize - 1) {\n    stop(paste0(\"The number of columns for spatial positions in the argument \",\n                \"'nt_distance' is more than max(setsize)-1\"))\n  }\n\n  if (any(data[,nt_distance] &lt; 0)) {\n    stop('Somve values of the spatial distance variables in the data are negative.\\n\n         All spatial distances to the target need to be postive.')\n  }\n\n  data = NextMethod(\"check_data\")\n\n  return(data)\n}\nThe IMM models share methods with the mixture3p model, all of which are of class nontargets so the check_data.nontargets method is defined in the general file R/helpers-data.R. If you are adding a new model, you should check if the data requirements are similar to any existing model and define the check_data method only for the methods that are unique to your model.\nThe check_data.mymodel() function should always take the arguments model, data, and formula and return the data with the necessary transformations. It should also call data = NextMethod(\"check_data\") to call the check_data method of the more general class.\n\n\n4.1.4 configure_model() methods\nThe configure_model.mymodel() method is where you specify the model formula, the family, any custom code, and the priors. The method is defined as follows for the IMM model:\n(we show only the IMMfull version)\nconfigure_model.IMMfull &lt;- function(model, data, formula) {\n  # retrieve arguments from the data check\n  max_setsize &lt;- attr(data, 'max_setsize')\n  lure_idx_vars &lt;- attr(data, \"lure_idx_vars\")\n  nt_features &lt;- model$other_vars$nt_features\n  setsize_var &lt;- model$other_vars$setsize\n  nt_distance &lt;- model$other_vars$nt_distance\n\n  # construct main brms formula from the bmm formula\n  bmm_formula &lt;- formula\n  formula &lt;- bmf2bf(model, bmm_formula)\n\n  # additional internal terms for the mixture model formula\n  kappa_nts &lt;- paste0('kappa', 2:max_setsize)\n  kappa_unif &lt;- paste0('kappa',max_setsize + 1)\n  theta_nts &lt;- paste0('theta',2:max_setsize)\n  mu_nts &lt;- paste0('mu', 2:max_setsize)\n  mu_unif &lt;- paste0('mu', max_setsize + 1)\n\n  formula &lt;- formula +\n    glue_lf(kappa_unif,' ~ 1') +\n    glue_lf(mu_unif, ' ~ 1') +\n    brms::nlf(theta1 ~ c + a) +\n    brms::nlf(kappa1 ~ kappa) +\n    brms::nlf(expS ~ exp(s))\n\n  for (i in 1:(max_setsize - 1)) {\n    formula &lt;- formula +\n      glue_nlf(kappa_nts[i], ' ~ kappa') +\n      glue_nlf(theta_nts[i], ' ~ ', lure_idx_vars[i], '*(exp(-expS*',nt_distance[i],')*c + a) + ',\n               '(1-', lure_idx_vars[i], ')*(-100)') +\n      glue_nlf(mu_nts[i], ' ~ ', nt_features[i])\n  }\n\n  # define mixture family\n  vm_list = lapply(1:(max_setsize + 1), function(x) brms::von_mises(link = \"identity\"))\n  vm_list$order = \"none\"\n  family &lt;- brms::do_call(brms::mixture, vm_list)\n\n  # define prior\n  additional_constants &lt;- list()\n  additional_constants[[kappa_unif]] &lt;- -100\n  additional_constants[[mu_unif]] &lt;- 0\n  prior &lt;- fixed_pars_priors(model, additional_constants) +\n    brms::prior_(\"normal(2, 1)\", class = \"b\", nlpar = \"kappa\") +\n    brms::prior_(\"normal(0, 1)\", class = \"b\", nlpar = \"c\") +\n    brms::prior_(\"normal(0, 1)\", class = \"b\", nlpar = \"a\") +\n    brms::prior_(\"normal(0, 1)\", class = \"b\", nlpar = \"s\")\n\n  # if there is setsize 1 in the data, set constant prior over thetant for setsize1\n  if ((1 %in% data$ss_numeric) && !is.numeric(data[[setsize_var]])) {\n    prior &lt;- prior +\n      brms::prior_(\"constant(0)\", class = \"b\", coef = paste0(setsize_var, 1), nlpar = \"a\") +\n      brms::prior_(\"constant(0)\", class = \"b\", coef = paste0(setsize_var, 1), nlpar = \"s\")\n  }\n\n  out &lt;- nlist(formula, data, family, prior)\n  return(out)\n}\nThe configure_model method should always take the arguments model, data, and formula (as a bmmformula) and return a named list with the formula (as a brmsformula), the data, the family, and the priors.\nInside the configure_model method the brmsformula is generated using the bmf2bf function. This function converts the bmmformula passed to fit_model function into a brmsformula based on the information for the response variables provided in the bmmmodel object. There is a general method in R/helpers-formula.R to construct the formula for all models with a single response variable.\n# default method for all bmmmodels with 1 response variable\n#' @export\nbmf2bf.bmmmodel &lt;- function(model, formula) {\n  # check if the model has only one response variable and extract if TRUE\n  resp &lt;- model$resp_vars\n  if (length(resp) &gt; 1) {\n    formula &lt;- NextMethod(\"bmf2bf\")\n    return(formula)\n  }\n  resp &lt;- resp[[1]]\n\n  # set base brms formula based on response\n  brms_formula &lt;- brms::bf(paste0(resp, \"~ 1\"))\n\n  # for each dependent parameter, check if it is used as a non-linear predictor of\n  # another parameter and add the corresponding brms function\n  dpars &lt;- names(formula)\n  for (dpar in dpars) {\n    pform &lt;- formula[[dpar]]\n    predictors &lt;- rhs_vars(pform)\n    if (any(predictors %in% dpars)) {\n      brms_formula &lt;- brms_formula + brms::nlf(pform)\n    } else {\n      brms_formula &lt;- brms_formula + brms::lf(pform)\n    }\n  }\n  brms_formula\n}\nFor models with more than one response variable, you will have to provide a model specific method of bmf2bf.myModel to convert the bmmformula into the brmsformula . This is done to avoid users having to specify complicated and long formulas specifying all additional response information in the brmsformula themselves. For more detailed information on the use of additional response information in a brmsformula please see the brmsformula documentation."
  },
  {
    "objectID": "example-model.html#the-signal-discrimination-model-sdm",
    "href": "example-model.html#the-signal-discrimination-model-sdm",
    "title": "4  Example model file",
    "section": "4.2 The Signal Discrimination Model (SDM)",
    "text": "4.2 The Signal Discrimination Model (SDM)\nThe SDM model is defined in the file R/bmm_model_SDM.R. The SDM model differs in the configuration compared to the IMM model, as it requires custom STAN code. Let’s go through the different parts. As before, we start with the model definition.\n\n4.2.1 Model definition\n.model_sdmSimple &lt;- function(resp_err, ...) {\n   out &lt;- list(\n      resp_vars = nlist(resp_err),\n      other_vars = nlist(),\n      info = list(\n         domain = 'Visual working memory',\n         task = 'Continuous reproduction',\n         name = 'Signal Discrimination Model (SDM) by Oberauer (2023)',\n         citation = paste0('Oberauer, K. (2023). Measurement models for visual working memory - ',\n                           'A factorial model comparison. Psychological Review, 130(3), 841-852'),\n         version = 'Simple (no non-targets)',\n         requirements = '- The response variable should be in radians and represent the angular error relative to the target',\n         parameters = list(\n            mu = 'Location parameter of the SDM distribution (in radians; by default fixed internally to 0)',\n            c = 'Memory strength parameter of the SDM distribution',\n            kappa = 'Precision parameter of the SDM distribution (log scale)'\n         ),\n         fixed_parameters = list(\n            mu = 0\n         )),\n      void_mu = FALSE\n   )\n   class(out) &lt;- c('bmmmodel', 'vwm', 'sdmSimple')\n   out\n}\nThe model definition is similar to the IMM model, but the SDM model only requires the user to specify the response error, but not additional variables such as non-target variables. The class is also different, as the SDM model is not a subclass of the IMM model. We’ll skip the alias for the SDM model, as it is similar for every model.\n\n\n4.2.2 check_data() methods\nThe SDM does not require special data checks beyond it’s shared class with other vwm models, so we don’t need to define a check_data.sdmSimple method. The check_data.vwm method is defined in the general file R/helpers-data.R.\n\n\n4.2.3 configure_model() methods\nThe configure_model method for the SDM model is different compared to the IMM model, as it requires custom STAN code. The method is defined as follows:\n#' @export\nconfigure_model.sdmSimple &lt;- function(model, data, formula) {\n    # construct the family\n    # note - c has a log link, but I've coded it manually for computational efficiency\n    sdm_simple &lt;- brms::custom_family(\n      \"sdm_simple\", dpars = c(\"mu\", \"c\",\"kappa\"),\n      links = c(\"identity\",\"identity\", \"log\"), lb = c(NA, NA, NA),\n      type = \"real\", loop=FALSE,\n    )\n    family &lt;- sdm_simple\n\n    # prepare initial stanvars to pass to brms, model formula and priors\n    sc_path &lt;- system.file(\"stan_chunks\", package=\"bmm\")\n    stan_funs &lt;- read_lines2(paste0(sc_path, '/sdmSimple_funs.stan'))\n    stan_tdata &lt;- read_lines2(paste0(sc_path, '/sdmSimple_tdata.stan'))\n    stan_likelihood &lt;- read_lines2(paste0(sc_path, '/sdmSimple_likelihood.stan'))\n    stanvars &lt;- brms::stanvar(scode = stan_funs, block = \"functions\") +\n      brms::stanvar(scode = stan_tdata, block = 'tdata') +\n      brms::stanvar(scode = stan_likelihood, block = 'likelihood', position =\"end\")\n\n    # construct main brms formula from the bmm formula\n    bmm_formula &lt;- formula\n    formula &lt;- bmf2bf(model, bmm_formula)\n\n    # construct the default prior\n    # TODO: for now it just fixes mu to 0, I have to add proper priors\n    prior &lt;- fixed_pars_priors(model)\n\n    # set initial values to be sampled between [-1,1] to avoid extreme SDs that\n    # can cause the sampler to fail\n    init = 1\n\n    # return the list\n    out &lt;- nlist(formula, data, family, prior, stanvars, init)\n    return(out)\n}\nLines 5-10 use the brms::custom_family function to define a custom family for the SDM model. The dpars argument specifies the parameters of the model, and the links argument specifies the link functions for the parameters. For more information, see here\nLines 13-22 read the custom stan code from the inst/stan_chunks directory. This has to be specified with the system.file() command to ensure that the code is found when the package is installed. The stanvars object is used to pass custom stan code to the brms package. The stanvars object is a list of brms::stanvar objects, each of which contains the stan code for a specific part of the model. There is a separate .stan file for each part of the stan code, and each file is read into a separate brms::stanvar object.\nConverting the bmmformula to a brmsformula, specifying priors for fixed parameters, and collecting all arguements is the same as for the IMM model.\nWe will now look at how to construct all these parts for a new model. Hint: you don’t have to do it manually, you can use the use_model_template() function to generate templates for your model."
  },
  {
    "objectID": "add-new-model.html",
    "href": "add-new-model.html",
    "title": "5  Adding a new model",
    "section": "",
    "text": "Function use_model_template()",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Adding a new model</span>"
    ]
  },
  {
    "objectID": "add-new-model.html#example",
    "href": "add-new-model.html#example",
    "title": "5  Adding a new model",
    "section": "5.1 Example",
    "text": "5.1 Example\nLet’s add a new model called gcm. Let’s assume that you have tested the model in Stan and you have the Stan code ready. We want to define a custom family for the gcm model, and we want to define the following blocks: likelihood, functions (see ?brms::stanvar for an explanation of the blocks).\nFirst you set up your system and git environment as described in Section 1. Then you can run the following code from RStudio in the root directory of the bmm package:\nuse_model_template(\"gcm\", custom_family = TRUE, stanvar_blocks = c(\"likelihood\", \"functions\"))\nThis will create the file bmm_model_gcm.R in the R/ directory and the files gcm_likelihood.stan and gcm_functions.stan in the inst/stan_chunks/ directory. The function will also open the files in RStudio. You will see the following output in the console:\n• Modify 'inst/stan_chunks/gcm_likelihood.stan'\n• Modify 'inst/stan_chunks/gcm_functions.stan'\n• Modify 'R/bmm_model_gcm.R'\nNow you can fill the files with the appropriate code. The stan files will be empty, but the R file will have the following structure:\n#############################################################################!\n# MODELS                                                                 ####\n#############################################################################!\n# see file 'R/bmm_model_mixture3p.R' for an example\n\n.model_gcm &lt;- function(resp_var1, required_arg1, required_arg2, ...) {\n   out &lt;- list(\n      resp_vars = nlist(resp_var1),\n      other_vars = nlist(required_arg1, required_arg2),\n      info = list(\n         domain = '',\n         task = '',\n         name = '',\n         citation = '',\n         version = '',\n         requirements = '',\n         parameters = list(),\n         fixed_parameters = list()\n      ),\n      void_mu = FALSE\n   )\n   class(out) &lt;- c('bmmmodel', 'gcm')\n   out\n}\n# user facing alias\n# information in the title and details sections will be filled in\n# automatically based on the information in the .model_gcm()$info\n \n#' @title `r .model_gcm()$info$name`\n#' @name Model Name#' @details `r model_info(gcm(NA,NA))`\n#' @param resp_var1 A description of the response variable\n#' @param required_arg1 A description of the required argument\n#' @param required_arg2 A description of the required argument\n#' @param ... used internally for testing, ignore it\n#' @return An object of class `bmmmodel`\n#' @export\n#' @examples\n#' \\dontrun{\n#' # put a full example here (see 'R/bmm_model_mixture3p.R' for an example)\n#' }\ngcm &lt;- .model_gcm\n\n\n#############################################################################!\n# CHECK_DATA S3 methods                                                  ####\n#############################################################################!\n# A check_data.* function should be defined for each class of the model.\n# If a model shares methods with other models, the shared methods should be\n# defined in data-helpers.R. Put here only the methods that are specific to\n# the model. See ?check_data for details\n\n#' @export\ncheck_data.gcm &lt;- function(model, data, formula) {\n   # retrieve required arguments\n   required_arg1 &lt;- model$other_vars$required_arg1\n   required_arg2 &lt;- model$other_vars$required_arg2\n\n   # check the data (required)\n\n\n   # compute any necessary transformations (optional)\n\n   # save some variables as attributes of the data for later use (optional)\n\n   data = NextMethod('check_data')\n\n   return(data)\n}\n\n\n#############################################################################!\n# Convert bmmformula to brmsformla methods                               ####\n#############################################################################!\n# A bmf2bf.* function should be defined if the default method for consructing\n# the brmsformula from the bmmformula does not apply\n# The shared method for all `bmmmodels` is defined in helpers-formula.R.\n# See ?bmf2bf for details.\n\n#' @export\nbmf2bf.gcm &lt;- function(model, formula) {\n   # retrieve required response arguments\n   resp_var1 &lt;- model$resp_vars$resp_var1\n   resp_var2 &lt;- model$resp_vars$resp_arg2\n\n   # set the base brmsformula based \n   brms_formula &lt;- brms::bf(paste0(resp_var1,\" | \", vreal(resp_var2), \" ~ 1\" ),)\n\n   # add bmmformula to the brms_formula\n   # check if parameters are used as non-linear predictors in other formulas\n   # and use the brms::lf() or brms::nlf() accordingly.\n   dpars &lt;- names(formula)\n   for (dpar in dpars) {\n     pform &lt;- formula[[dpar]]\n     predictors &lt;- rhs_vars(pform)\n     if (any(predictors %in% dpars)) {\n       brms_formula &lt;- brms_formula + brms::nlf(pform)\n     } else {\n       brms_formula &lt;- brms_formula + brms::lf(pform)\n     }\n   }\n\n   return(brms_formula)\n}\n\n\n#############################################################################!\n# CONFIGURE_MODEL S3 METHODS                                             ####\n#############################################################################!\n# Each model should have a corresponding configure_model.* function. See\n# ?configure_model for more information.\n\n#' @export\nconfigure_model.gcm &lt;- function(model, data, formula) {\n   # retrieve required arguments\n   required_arg1 &lt;- model$other_vars$required_arg1\n   required_arg2 &lt;- model$other_vars$required_arg2\n\n   # retrieve arguments from the data check\n   my_precomputed_var &lt;- attr(data, 'my_precomputed_var')\n\n   # construct brms formula from the bmm formula\n   bmm_formula &lt;- formula\n   formula &lt;- bmf2bf(model, bmm_formula)\n\n   # construct the family\n   gcm_family &lt;- brms::custom_family(\n     'gcm',\n     dpars = c(),\n     links = c(),\n     lb = c(), # upper bounds for parameters\n     ub = c(), # lower bounds for parameters\n     type = '', # real for continous dv, int for discrete dv\n     loop = TRUE, # is the likelihood vectorized\n   )\n   family &lt;- gcm_family\n\n   # prepare initial stanvars to pass to brms, model formula and priors\n   sc_path &lt;- system.file('stan_chunks', package='bmm')\n   stan_likelihood &lt;- readChar(paste0(sc_path, '/gcm_likelihood.stan'),\n      file.info(paste0(sc_path, '/gcm_likelihood.stan'))$size)\n   stan_functions &lt;- readChar(paste0(sc_path, '/gcm_functions.stan'),\n      file.info(paste0(sc_path, '/gcm_functions.stan'))$size)\n\n   stanvars &lt;- stanvar(scode = stan_likelihood, block = 'likelihood') +\n      stanvar(scode = stan_functions, block = 'functions')\n\n   # construct the default prior\n   prior &lt;- NULL\n\n   # return the list\n   out &lt;- nlist(formula, data, family, prior, stanvars)\n   return(out)\n}\n\n\n#############################################################################!\n# POSTPROCESS METHODS                                                    ####\n#############################################################################!\n# A postprocess_brm.* function should be defined for the model class. See \n# ?postprocess_brm for details\n\n#' @export\npostprocess_brm.gcm &lt;- function(model, fit) {\n   # any required postprocessing (if none, delete this section)\n\n   return(fit)\n}\nNow you have to:\n\nFill the .model_gcm function with the appropriate code. This function should return a list with the variables that the model needs and a list with information about the model. The class of the list should be c('bmmmodel', 'gcm'). The information list should contain the following elements: domain, task, name, citation, version, requirements, and parameters. Rename the response arguements and the other required arguments, or delete the other arguments if you do not have any. You can see an example in the bmm_model_sdmSimple.R file.\nAdjust the user-facing alias. Here you should only rename the required arguments and fill in the @examples section with a full example. Everything else will be filled in automatically based on the information in the .model_gcm function.\nFill the check_data.gcm function with the appropriate code. This function should check the data and return the data. You may or may not need to compute any transformations or save some variables as attributes of the data.\nIf necessary define the bmf2bf.gcm method to convert the bmmformula to a brmsformula. The first step for this is always to specify the response variable and additional response information. Keep in mind that brms automatically interprets this formula as the linear model formula for the mu parameter of your custom family. Currently, brms requires all custom families to have a mu parameter. However, we recommend to code this parameter as a void_mu, and fix the intercept of this parameter to zero using constant priors. This way, the bmmformula can be used to only specify the linear or non-linear model for the parameters of a bmmmodel.\nFill the configure_model.gcm function with the appropriate code. This function should construct the formula, the family, the stanvars, and the prior. You can also retrieve any arguments you saved from the data check. Depending on your model, some of these parts might not be necessary. For example, for the mixture models (e.g. mixture3p), we construct a new formula, because we want to rename the arguments to make it easier for the user. For the sdmSimple model, we define the family ourselves, so we don’t need to change the formula.\nYou need to fill information about your custom family, and then fill the STAN files with your STAN code. Conveniently, you don’t have to edit lines 137-145: loading the STAN files and setting up the stanvars is set up automatically when calling the use_model_template function. Should you need to add more STAN files after you created the template, you can add the files in init/stan_chunks/ manually and edit those lines to additionally load the manually added files.\nFill the postprocess_brm.gcm function with the appropriate code. By postprocessing, we mean changes to the fitted brms model - like renaming parameters, etc. If you don’t need any postprocessing, you can delete this section."
  },
  {
    "objectID": "add-new-model.html#testing",
    "href": "add-new-model.html#testing",
    "title": "5  Adding a new model",
    "section": "5.2 Testing",
    "text": "5.2 Testing\nUnit testing is extremely important. You should test your model with the testthat package. You can use the use_test() function to create a test file for your model. See file tests/testthat/test-fit_model.R for an example of how we test the existing models. BRMS models take a long time to fit, so we don’t test the actual fitting process. fit_model() provides an argument backend=\"mock\", which will return a mock object instead of fitting the model. This ensures that the entire pipeline works without errors. For example, here’s a test of the IMMfull model:\ntest_that('Available mock models run without errors',{\n  withr::local_options('bmm.silent'=2)\n  skip_on_cran()\n  dat &lt;- data.frame(\n    resp_err = rIMM(n = 5),\n    Item2_rel = 2,\n    Item3_rel = -1.5,\n    spaD2 = 0.5,\n    spaD3 = 2\n  )\n\n  # two-parameter model mock fit\n  f &lt;- bmmformula(kappa ~ 1, c ~ 1, a ~ 1, s ~ 1)\n  mock_fit &lt;- fit_model(f, dat, IMMfull(resp_err = \"resp_err\", setsize = 3, nt_features = paste0('Item',2:3,'_rel'), nt_distance=paste0('spaD',2:3)), backend = \"mock\", mock_fit = 1, rename=FALSE)\n  expect_equal(mock_fit$fit, 1)\n  expect_type(mock_fit$fit_args, \"list\")\n  expect_equal(names(mock_fit$fit_args[1:4]), c(\"formula\", \"data\", \"family\", \"prior\"))\n})\nThe tests based on the testthat package are run every time you call the check() command. Before you submit your changes, make sure that all tests pass.\n\n\n\n\n\n\nImportant\n\n\n\nAdditionally, you should perform a full test of the model by running it in a separate script and ensuring it gives meaningful results. At the very least, you should perform basic parameter recovery simulations for hyper-parameters (i.e. means and standard deviations) as well as subject-level parameters to give users an idea of how much data they need to adequately estimate the model.\nWe are in the process of establishing guidelines for that."
  },
  {
    "objectID": "add-new-model.html#add-an-example-dataset",
    "href": "add-new-model.html#add-an-example-dataset",
    "title": "5  Adding a new model",
    "section": "5.3 Add an example dataset",
    "text": "5.3 Add an example dataset\nAll new models should come with an example dataset, that can be loaded by users and that can be used in the examples section. This should be one of:\n\nA new dataset that you add to the package\nA dataset that already exists in the package but that can be used with the new model\nA dataset that exists in another package that you can load with data() and use with the new model\n\nFor example, the vignettes for the mixture2p and mixture3p use an external dataset from the mixtur package that can be loaded with data('bays2009_full', package='mixtur'). The IMM models use a dataset included in the current package. For instructions on how to add a new dataset see here."
  },
  {
    "objectID": "add-new-model.html#add-a-vignette",
    "href": "add-new-model.html#add-a-vignette",
    "title": "5  Adding a new model",
    "section": "5.4 Add a vignette",
    "text": "5.4 Add a vignette\nAll new models should come with a vignette that explains some basic information about the model and how to estimate it with bmm. You can use the use_vignette() function to create a new vignette. See here for more information. The vignettes will be published automatically on the package website under “Articles” when the pull request is approved. You can browse the source code for the existing vignettes in the vignettes/ directory. You can see the published version of the existing vignettes here.\nAnd that’s it! You have added a new model to the bmm package. You can now submit your changes to the bmm package repository."
  }
]