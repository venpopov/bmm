[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "BMM Developer Notes",
    "section": "",
    "text": "Overview\nLast update: 13.08.2024\nThis guide aims to help developers contribute new models to bmm. It is a work in progress and will be updated as the package evolves. It explains how to set-up your system for package development, the structure of the package, and the workflow for contributing new models to the package.\nThe current guide is up to date with bmm v1.0.1 and it might not yet reflect changes implemented afterwards. If you run into problems, don’’t hesitate to open an issue on github.\nWe follow a github flow workflow. The repository contains two main branches:\n\nMaster (contains the latest released stable version of the bmm package)\nDevelop (contains the latest stable development branch)\n\nAll new feature development should occur on an independent branch from Develop. If you want to contribute a new model to the bmm package, you need to fork the repository, create a new branch for your model, extensively test the model, and eventually submit a pull request for your changes to be merged into the Develop branch of the main repository. Your changes will be reviewed by someone from the core team. Once your changes are merged into the Develop branch, they will be included in the next release of the package.",
    "crumbs": [
      "Overview"
    ]
  },
  {
    "objectID": "setup.html",
    "href": "setup.html",
    "title": "1  System setup",
    "section": "",
    "text": "1.1 Setting up a local fork of the bmm repository",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>System setup</span>"
    ]
  },
  {
    "objectID": "setup.html#setting-up-a-local-fork-of-the-bmm-repository",
    "href": "setup.html#setting-up-a-local-fork-of-the-bmm-repository",
    "title": "1  System setup",
    "section": "",
    "text": "Fork the bmm github repository. This will create a copy of the current development branch into your own github account\n\nClone your fork to your local machine\nCreate a new branch for your model, typically named feature/name-of-my-model",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>System setup</span>"
    ]
  },
  {
    "objectID": "setup.html#package-development-via-rstudio-and-devtools",
    "href": "setup.html#package-development-via-rstudio-and-devtools",
    "title": "1  System setup",
    "section": "1.2 Package development via RStudio and devtools",
    "text": "1.2 Package development via RStudio and devtools\nThe bmm package is setup as an RStudio project. Opening the bmm.Rproj file will open a new RStudio instance, which facilitates package development with a few commands from the devtools package. A great tutorial on package development can be found here. Below is a summary of the most important steps\n\nMake sure you have the devtools package and a few others installed and loaded\ninstall.packages(c(\"devtools\", \"roxygen2\", \"testthat\", \"knitr\"))\nlibrary(devtools)\ninstall_dev_deps()\nTo avoid having to load the devtools package every time, you can add the following code to your .Rprofile file\nif (interactive()) {\n  suppressMessages(require(devtools))\n}\nAs noted here, you can create and open an .Rprofile file, if you don’t already have one with\nuse_devtools()\nLoad the current version of the bmm package based on your local files\nload_all()  # or ctrl+shift+L\nyou can use this command whenever you make changes to the package code to see the changes in action. You should not call library(bmm) or source the files manually, as this will load the installed version of the package, not the one you are developing.\nMake any changes to the package code that you need to make (elaborated in the next section)\nUse check() to check the package for errors and warnings\ncheck()\nyou should always ensure that check() produces no errors before submitting a pull request\nUse document() to update the documentation\ndocument()",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>System setup</span>"
    ]
  },
  {
    "objectID": "git-workflow.html",
    "href": "git-workflow.html",
    "title": "2  Git and Github workflow",
    "section": "",
    "text": "2.1 Git commands\nAdd your changes to git, commit them and then push your changes to your forked repository. You can run these commands from a terminal or from the RStudio terminal (with the project working directory)\nAdd all changed files to the staging area:\nCommit the changes to the local repository\nPush the changes to your forked repository\nYou can (and should) repeat this process as many times as you need to before submitting a pull request. This will allow you to make many small changes and test them before submitting a pull request. Ideally each commit should be a small, self-contained change that can be easily reviewed.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Git and Github workflow</span>"
    ]
  },
  {
    "objectID": "git-workflow.html#git-commands",
    "href": "git-workflow.html#git-commands",
    "title": "2  Git and Github workflow",
    "section": "",
    "text": "git add *  \n\ngit commit -m \"A short message describing the changes you made\"\n\ngit push",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Git and Github workflow</span>"
    ]
  },
  {
    "objectID": "git-workflow.html#pull-requests",
    "href": "git-workflow.html#pull-requests",
    "title": "2  Git and Github workflow",
    "section": "2.2 Pull requests",
    "text": "2.2 Pull requests\nWhen you are ready you can open a pull request from your forked repository to the main bmm repository. You can do this from the github website. Make sure to select the Develop branch as the base branch and your feature branch as the compare branch. You should add a detailed description of your changes, including the motivation for the changes and any relevant context. You should also mention any issues that your pull request resolves.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Git and Github workflow</span>"
    ]
  },
  {
    "objectID": "bmm-architecture.html",
    "href": "bmm-architecture.html",
    "title": "3  BMM code structure",
    "section": "",
    "text": "3.1 The main workhorse - bmm()\nThe main function for fitting models is bmm(). This function is the main entry point for users to fit models. It is set-up to be independent of the specific models that are implemented in the package.\nIt calls several subroutines, implemented as generic S3 methods, to:\nIn addition, it also tests if the specified bmmodel has already been estimated and saved to a file. This is done via the read_bmmfit and save_bmmfit functions.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>BMM code structure</span>"
    ]
  },
  {
    "objectID": "bmm-architecture.html#the-main-workhorse---bmm",
    "href": "bmm-architecture.html#the-main-workhorse---bmm",
    "title": "3  BMM code structure",
    "section": "",
    "text": "bmm &lt;- function(formula, data, model,\n                prior = NULL,\n                sort_data = getOption('bmm.sort_data', \"check\"),\n                silent = getOption('bmm.silent', 1),\n                backend = getOption('brms.backend', NULL),\n                file = NULL, file_compress = TRUE,\n                file_refit = getOption('bmm.file_refit', FALSE), ...) {\n  deprecated_args(...)\n  dots &lt;- list(...)\n\n  x &lt;- read_bmmfit(file, file_refit)\n  if (!is.null(x)) return(x)\n\n  # set temporary global options and return modified arguments for brms\n  configure_opts &lt;- nlist(sort_data, silent, backend, parallel = dots$parallel,\n                          cores = dots$cores)\n  opts &lt;- configure_options(configure_opts)\n  dots$parallel &lt;- NULL\n\n  # check model, formula and data, and transform data if necessary\n  user_formula &lt;- formula\n  model &lt;- check_model(model, data, formula)\n  data &lt;- check_data(model, data, formula)\n  formula &lt;- check_formula(model, data, formula)\n\n  # generate the model specification to pass to brms later\n  config_args &lt;- configure_model(model, data, formula)\n\n  # configure the default prior and combine with user-specified prior\n  prior &lt;- configure_prior(model, data, config_args$formula, prior)\n\n  # estimate the model\n  fit_args &lt;- combine_args(nlist(config_args, opts, dots, prior))\n  fit &lt;- call_brm(fit_args)\n\n  # model post-processing\n  fit &lt;- postprocess_brm(model, fit, fit_args = fit_args, user_formula = user_formula,\n                         configure_opts = configure_opts)\n\n  # save the fitted model object if !is.null\n  save_bmmfit(fit, file, compress = file_compress)\n}\n\n\nconfigure_options() - to configure local options for fitting, such as parallel sampling,\ncheck_model() - check if the model exists\ncheck_formula() - check if the formula is specified correctly and transform it to a brmsformula\ncheck_data() - check whether the data contains all necessary information\nconfigure_model() - configures the model called for fitting\nconfigure_prior() - sets the default priors for the model and combines them with the user prior\ncall_brm() - fit the model using the brm() function from the brms package\npostprocess_brm() - to post-process the fitted model",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>BMM code structure</span>"
    ]
  },
  {
    "objectID": "bmm-architecture.html#models",
    "href": "bmm-architecture.html#models",
    "title": "3  BMM code structure",
    "section": "3.2 Models",
    "text": "3.2 Models\nAll models in the package are defined as S3 classes and follow a strict template. This allows us to implement general methods for handling model fitting, data checking, and post-processing. Each model has an internal function that defines the model and its parameters, and a user-facing alias. For a complete example model file and an explanation, see Section 4. The general model template looks like this:\n.model_my_new_model &lt;- function(resp_var1 = NULL, required_args1 = NULL, \n                                required_arg2 = NULL, links = NULL, version = NULL,\n                                call = NULL, ...) {\n  out &lt;- structure(\n    list(\n      resp_vars = nlist(resp_error),\n      other_vars = nlist(),\n      domain = \"\",\n      task = \"\",\n      name = \"\",\n      version = \"\",\n      citation = \"\",\n      requirements = \"\",\n      parameters = list(),\n      links = list(),\n      fixed_parameters = list(),\n      default_priors = list(),\n      version = version,\n      void_mu = FALSE\n    ),\n    class = c(\"bmmodel\", \"my_new_model\"),\n    call = call\n  )\n  out$links[names(links)] &lt;- links\n  out\n}\nEach model is accompanied by a user-facing alias, the documentation of which is generated automatically based on the info list in the model definition.\n# user facing alias\n# information in the title and details sections will be filled in\n# automatically based on the information in the .model_modelname()$info\n#' @title `r .model_my_new_model()name`\n#' @name Model Name#' @details `r model_info(.model_my_new_model())`\n#' @param resp_var1 A description of the response variable\n#' @param required_arg1 A description of the required argument\n#' @param required_arg2 A description of the required argument\n#' @param ... used internally for testing, ignore it\n#' @return An object of class `bmmmodel`\n#' @export\n#' @examples\n#' \\dontrun{\n#' # put a full example here (see 'R/bmm_model_mixture3p.R' for an example)\n#' }\nmy_new_model &lt;- function(resp_var1, required_arg1, required_arg2, \n                         links = NULL, version = NULL, ...) {\n  call &lt;- match.call()\n  stop_missing_args()\n  .model_my_new_model(resp_var1 = resp_var1, required_arg1 = required_arg1,\n                      required_arg2 = required_arg2, links = links, version = version,\n                      call = call, ...)\n}\nThen users can fit the model using the bmm() function, and the model will be automatically recognized and handled by the package:\nfit &lt;- bmm(formula = my_bmmformula, \n           data = my_data, \n           model = my_new_model(resp_var1, required_arg1, required_arg2))",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>BMM code structure</span>"
    ]
  },
  {
    "objectID": "bmm-architecture.html#s3-methods",
    "href": "bmm-architecture.html#s3-methods",
    "title": "3  BMM code structure",
    "section": "3.3 S3 methods",
    "text": "3.3 S3 methods\nThe package uses S3 methods to handle different models. This means that the same function can behave differently depending on the class of the object it is called with. For example, the configure_model(model) function called by fit_model(), is generally defined as:\nconfigure_model &lt;- function(model) {\n   UseMethod('configure_model')\n}\nand it will call a function configure_model.modelname() that is specified for each model. The same is true for other functions, such as check_data(), postprocess_brm(), and check_formula(). This allows us to add new models without having to edit the main fitting function, bmm().",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>BMM code structure</span>"
    ]
  },
  {
    "objectID": "bmm-architecture.html#file-organization",
    "href": "bmm-architecture.html#file-organization",
    "title": "3  BMM code structure",
    "section": "3.4 File organization",
    "text": "3.4 File organization\nThe bmm package is organized into several files. The main files are:\n\nR/bmm.R\nIt contains the main function for fitting models, bmm(). This function is the main entry point for users to fit models. It is set-up to be independent of the specific models that are implemented in the package.\nTo add new models, you do not have to edit this file. The functions above are generic S3 methods, and they will automatically recognize new models if you add appropriate methods for them (see section Adding new models).\n\n\nR/helpers-*.R\nR/helpers-data.R, R/helpers-parameters.R, R/helpers-postprocess.R, R/helpers-model.R, and R/helpers-prior.R\nThese files define the main generic S3 methods for checking data, post-processing the fitted model, configuring the model, checking the model formula, and combining priors. They contain the default methods for these functions, which are called by bmm() if no specific method is defined for a model. If you want to add a new model, you will need to add specific methods for these functions for your model. You do not need to edit these files to add a new model.\n\n\nR/bmmformula.R\nThis file contains the definition of the bmmformula class, which is used to represent the formula for the model. It contains the bmmformula() function and its alias bmf(), which is used to create a new formula object.\nIn addition, it contains the definition of the bmf2bf S3 method that is used to convert a bmmformula object into a brms_formula`object. This is necessary, as brmsformula objects are required to include the response variable in the first formula line. In contrast bmmformula objects only contain formulas predicting the paramaeters of a bmmmodel. The bmf2bf S3 method is used to perform this conversion and add the first formula line and including the response variable in the brmsformula created during model configuration.\n\n\nR/model_*.R\nEach model and it’s methods is defined in a separate file. For example, the 3-parameter mixture model is defined in model_mixture3p.R. This file contains the internal function that defines the model and its parameters, and the specific methods for the generic S3 functions. Your new model will exist in a file like this. The name of the file should be model_name_of_your_model.R. You don’t have to add this file manually - see section Adding new models.\n\n\nR/distributions.R\nThis file contains the definition of the custom distributions that are used in the package. It specifies the density, random number generation, and probability functions for the custom distributions. If your model requires a custom distribution, you will need to add it to this file. These are not used during model fitting, but can be used to generate data from the model, and to plot the model fit.\n\n\nR/utils.R, R/brms-misc.R, R/restructure.R, R/summary.R, R/update.R\nVarious utility functions.\n\n\ninst/stan_chunks/\nThis directory contains the Stan chunks that are passed to the brms::stanvar() function. These are used to define the custom distributions that are used in the package. If you add a new custom distribution, you will need to add a new Stan chunk to this directory. Each model has several files, one for each corresponding stanvar block.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>BMM code structure</span>"
    ]
  },
  {
    "objectID": "example-model.html",
    "href": "example-model.html",
    "title": "4  Example model file",
    "section": "",
    "text": "4.1 The Interference Measurement Model (IMM)\nThe model is defined in the file R/model_imm.R. Let’s go through the different parts.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Example model file</span>"
    ]
  },
  {
    "objectID": "example-model.html#the-interference-measurement-model-imm",
    "href": "example-model.html#the-interference-measurement-model-imm",
    "title": "4  Example model file",
    "section": "",
    "text": "4.1.1 Model definition\nThe full IMM model is defined in the following internal model class:\n.model_imm &lt;-\n  function(resp_error = NULL, nt_features = NULL, nt_distances = NULL,\n           set_size = NULL, regex = FALSE, version = \"full\", links = NULL,\n           call = NULL, ...) {\n    out &lt;- structure(\n      list(\n        resp_vars = nlist(resp_error),\n        other_vars = nlist(nt_features, nt_distances, set_size),\n        domain = \"Visual working memory\",\n        task = \"Continuous reproduction\",\n        name = \"Interference measurement model by Oberauer and Lin (2017).\",\n        version = version,\n        citation = glue(\n          \"Oberauer, K., & Lin, H.Y. (2017). An interference model \\\\\n          of visual working memory. Psychological Review, 124(1), 21-59\"\n        ),\n        requirements = glue(\n          '- The response vairable should be in radians and \\\\\n          represent the angular error relative to the target\n          - The non-target features should be in radians and be \\\\\n          centered relative to the target'\n        ),\n        parameters = list(\n          mu1 = glue(\n            \"Location parameter of the von Mises distribution for memory \\\\\n            responses (in radians). Fixed internally to 0 by default.\"\n          ),\n          kappa = \"Concentration parameter of the von Mises distribution\",\n          a = \"General activation of memory items\",\n          c = \"Context activation\",\n          s = \"Spatial similarity gradient\"\n        ),\n        links = list(\n          mu1 = \"tan_half\",\n          kappa = \"log\",\n          a = \"log\",\n          c = \"log\",\n          s = \"log\"\n        ),\n        fixed_parameters = list(mu1 = 0, mu2 = 0, kappa2 = -100),\n        default_priors = list(\n          mu1 = list(main = \"student_t(1, 0, 1)\"),\n          kappa = list(main = \"normal(2, 1)\", effects = \"normal(0, 1)\"),\n          a = list(main = \"normal(0, 1)\", effects = \"normal(0, 1)\"),\n          c = list(main = \"normal(0, 1)\", effects = \"normal(0, 1)\"),\n          s = list(main = \"normal(0, 1)\", effects = \"normal(0, 1)\")\n        ),\n        void_mu = FALSE\n      ),\n      # attributes\n      regex = regex,\n      regex_vars = c('nt_features', 'nt_distances'),\n      class = c(\"bmmodel\", \"circular\", \"non_targets\", \"imm\", paste0('imm_',version)),\n      call = call\n    )\n\n    # add version specific information\n    if (version == \"abc\") {\n      out$parameters$s &lt;- NULL\n      out$links$s &lt;- NULL\n      out$default_priors$s &lt;- NULL\n      attributes(out)$regex_vars &lt;- c('nt_features')\n    } else if (version == \"bsc\") {\n      out$parameters$a &lt;- NULL\n      out$links$a &lt;- NULL\n      out$default_priors$a &lt;- NULL\n    }\n\n    out$links[names(links)] &lt;- links\n    out\n  }\nHere is a brief explanation of the different components of the model definition:\nresp_vars: a list of response variables that the model will be fitted to. These variables will be used to construct the brmsformula passed to brms together with the bmmformula and the parameters of the model. The user has to provide these variables in the data frame that is passed to the bmm() function\nother_vars: a list of additional variables that are required for the model. This is used to check if the data contains all necessary information for fitting the model. In the example above, the IMM model requires the names of the variables specifying the non-target features relative to the target, the variables specifying the distance of the non-targets to the target, and the set_size. The user has to provide these variables in the data frame that is passed to the bmm() function\ndomain, task, name, citation, requirements: contains information about the model, such as the domain, task, name, citation, requirements. This information is used for generating help pages\nversion: if the model has multiple versions, this argument is specified by the user. Then it is used to dynamically adjust some information in the model object. In the case of the imm model, we have three versions - full, bsc and abc. As you can see at the end of the script, some parameters are deleted depending on the model version.\nparameters: contains a named list of all parameters in the model that can be estimated by the user and their description. This information is used internally to check if the bmmformula contains linear model formulas for all model parameters, and to decide what information to include in the summary of bmmfit objects.\nlinks: a named list providing the link function for each parameter. For example, kappa in the imm models has to be positive, so it is sampled on the log scale. This information is used in defining the model family and for the summary methods. If you want the user to be able to specify custom link functions, the next to last line of the script replaces the links with those provided by the user\nfixed_parameters in the imm several parameters are fixed to constant values internally to identify the model. Only one of them, mu1 is also part of the parameters block - this is the only fixed parameters that users can choose to estimate instead of leaving it fixed. mu2 and kappa2 cannot be freely estimated.\ndefault_priors a list of lists for each parameter in the model. Each prior has two components: main, the prior that will be put on the Intercept or on each level of a factor if the intercept is suppressed; effects, the prior to put on the regression coefficients relative to the intercept. The priors are described as in the set_prior function from brms. This information is used by the configure_prior() S3 method to automatically set the default priors for the model. The priors that you put here will be used by bmm() unless the users chooses to overwrite them.\nvoid_mu: For models using a custom family that do not contain a location or mu parameter, for example the diffusion model, we recommend setting up a void_mu parameter. This avoids arbitrarily using one of the model parameters as the mu parameter.\nregex: For the imm models, the nt_features and nt_distances variables can be specified with regular expressions, if the user sets regex = TRUE\ncall: this automatically records how the model was called so that the call can be printed in the summary after fitting. Leave it as is.\nclass: is the most important part. It contains the class of the model. This is used by generic S3 methods to perform data checks and model configuration. The classes should be ordered from most general to most specific. A general class exists when the same operations can be performed on multiple models. For example, the ‘3p’, ‘imm_abc’, ‘imm_bsc’ and ‘imm_full’ models all have non-targets and set_size arguments, so the same data checks can be performed on all of them, represented by the class non_targets. The first class should always be bmmodel, which is the main class for all models. The last class should be the specific model name, in this case imm_full, imm_abc or imm_bsc, which is automatically constructed if a version argument is provided. Otherwise the last class will be just the name of the model.\n\n\n4.1.2 Model alias\nThe model alias is a user-facing function that calls the internal model function. It is defined as follows:\n#' @title `r .model_imm()$name`\n#' @description Three versions of the `r .model_imm()$name` - the full, bsc, and abc.\n#' `IMMfull()`, `IMMbsc()`, and `IMMabc()` are deprecated and will be removed in the future.\n#' Please use `imm(version = 'full')`, `imm(version = 'bsc')`, or `imm(version = 'abc')` instead.\n#'\n#' @name imm\n#' @details `r model_info(.model_imm(), components =c('domain', 'task', 'name', 'citation'))`\n#' #### Version: `full`\n#' `r model_info(.model_imm(version = \"full\"), components = c('requirements', 'parameters', 'fixed_parameters', 'links', 'prior'))`\n#' #### Version: `bsc`\n#' `r model_info(.model_imm(version = \"bsc\"), components = c('requirements', 'parameters', 'fixed_parameters', 'links', 'prior'))`\n#' #### Version: `abc`\n#' `r model_info(.model_imm(version = \"abc\"), components =c('requirements', 'parameters', 'fixed_parameters', 'links', 'prior'))`\n#'\n#' Additionally, all imm models have an internal parameter that is fixed to 0 to\n#' allow the model to be identifiable. This parameter is not estimated and is not\n#' included in the model formula. The parameter is:\n#'\n#'   - b = \"Background activation (internally fixed to 0)\"\n#'\n#' @param resp_error The name of the variable in the provided dataset containing\n#'   the response error. The response Error should code the response relative to\n#'   the to-be-recalled target in radians. You can transform the response error\n#'   in degrees to radian using the `deg2rad` function.\n#' @param nt_features A character vector with the names of the non-target\n#'   variables. The non_target variables should be in radians and be centered\n#'   relative to the target. Alternatively, if regex=TRUE, a regular\n#'   expression can be used to match the non-target feature columns in the\n#'   dataset.\n#' @param nt_distances A vector of names of the columns containing the distances\n#'   of non-target items to the target item. Alternatively, if regex=TRUE, a regular\n#'   expression can be used to match the non-target distances columns in the\n#'   dataset. Only necessary for the `bsc` and `full` versions.\n#' @param set_size Name of the column containing the set size variable (if\n#'   set_size varies) or a numeric value for the set_size, if the set_size is\n#'   fixed.\n#' @param regex Logical. If TRUE, the `nt_features` and `nt_distances` arguments\n#'   are interpreted as a regular expression to match the non-target feature\n#'   columns in the dataset.\n#' @param version Character. The version of the IMM model to use. Can be one of\n#'  `full`, `bsc`, or `abc`. The default is `full`.\n#' @param ... used internally for testing, ignore it\n#' @return An object of class `bmmodel`\n#' @keywords bmmodel\n#' @examplesIf isTRUE(Sys.getenv(\"BMM_EXAMPLES\"))\n#' # load data\n#' data &lt;- oberauer_lin_2017\n#'\n#' # define formula\n#' ff &lt;- bmmformula(\n#'   kappa ~ 0 + set_size,\n#'   c ~ 0 + set_size,\n#'   a ~ 0 + set_size,\n#'   s ~ 0 + set_size\n#' )\n#'\n#' # specify the full IMM model with explicit column names for non-target features and distances\n#' # by default this fits the full version of the model\n#' model1 &lt;- imm(resp_error = \"dev_rad\",\n#'               nt_features = paste0('col_nt', 1:7),\n#'               nt_distances = paste0('dist_nt', 1:7),\n#'               set_size = 'set_size')\n#'\n#' # fit the model\n#' fit &lt;- bmm(formula = ff,\n#'            data = data,\n#'            model = model1,\n#'            cores = 4,\n#'            backend = 'cmdstanr')\n#'\n#' # alternatively specify the IMM model with a regular expression to match non-target features\n#' # this is equivalent to the previous call, but more concise\n#' model2 &lt;- imm(resp_error = \"dev_rad\",\n#'               nt_features = 'col_nt',\n#'               nt_distances = 'dist_nt',\n#'               set_size = 'set_size',\n#'               regex = TRUE)\n#'\n#' # fit the model\n#' fit &lt;- bmm(formula = ff,\n#'            data = data,\n#'            model = model2,\n#'            cores = 4,\n#'            backend = 'cmdstanr')\n#'\n#' # you can also specify the `bsc` or `abc` versions of the model to fit a reduced version\n#' model3 &lt;- imm(resp_error = \"dev_rad\",\n#'               nt_features = 'col_nt',\n#'               set_size = 'set_size',\n#'               regex = TRUE,\n#'               version = 'abc')\n#' fit &lt;- bmm(formula = ff,\n#'            data = data,\n#'            model = model3,\n#'            cores = 4,\n#'            backend = 'cmdstanr')\n#' @export\nimm &lt;- function(resp_error, nt_features, nt_distances, set_size, regex = FALSE, version = \"full\", ...) {\n  call &lt;- match.call()\n  dots &lt;- list(...)\n  if (\"setsize\" %in% names(dots)) {\n    set_size &lt;- dots$setsize\n    warning(\"The argument 'setsize' is deprecated. Please use 'set_size' instead.\")\n  }\n  if (version == \"abc\") {\n    nt_distances &lt;- NULL\n  }\n  stop_missing_args()\n  .model_imm(resp_error = resp_error, nt_features = nt_features,\n             nt_distances = nt_distances, set_size = set_size, regex = regex,\n             version = version, call = call, ...)\n}\nThe details will be filled out automatically from the model definition. This does some fancy formatting to include documentation about all versions of the model in the same help file.\n\n\n4.1.3 check_data() methods\nEach model should have a check_data.modelname() method that checks if the data contains all necessary information for fitting the model. For the IMM, the bsc and full versions require a special check for the nt_distances variables:\n#' @export\ncheck_data.imm_bsc &lt;- function(model, data, formula) {\n  data &lt;- .check_data_imm_dist(model, data, formula)\n  NextMethod(\"check_data\")\n}\n\n#' @export\ncheck_data.imm_full &lt;- function(model, data, formula) {\n  data &lt;- .check_data_imm_dist(model, data, formula)\n  NextMethod(\"check_data\")\n}\n\n.check_data_imm_dist &lt;- function(model, data, formula) {\n  nt_distances &lt;- model$other_vars$nt_distances\n  max_set_size &lt;- attr(data, 'max_set_size')\n\n  stopif(!isTRUE(all.equal(length(nt_distances), max_set_size - 1)),\n         \"The number of columns for non-target distances in the argument \\\\\n         'nt_distances' should equal max(set_size)-1})\")\n\n  # replace nt_distances\n  data[,nt_distances][is.na(data[,nt_distances])] &lt;- 999\n\n  stopif(any(data[,nt_distances] &lt; 0),\n         \"All non-target distances to the target need to be postive.\")\n  data\n}\nThe IMM models share methods with the mixture3p model, all of which are of class non_targets so the check_data.non_targets method is defined in the general file R/helpers-data.R. If you are adding a new model, you should check if the data requirements are similar to any existing model and define the check_data method only for the methods that are unique to your model.\nThe check_data.mymodel() function should always take the arguments model, data, and formula and return the data with the necessary transformations. It should also call data = NextMethod(\"check_data\") to call the check_data method of the more general class.\n\n\n4.1.4 configure_model() methods\nThe configure_model.mymodel() method is where you specify the model formula, the family, any custom code. The method is defined as follows for the IMM model:\n(we show only the IMMfull version)\nconfigure_model.imm_full &lt;- function(model, data, formula) {\n  # retrieve arguments from the data check\n  max_set_size &lt;- attr(data, 'max_set_size')\n  lure_idx &lt;- attr(data, \"lure_idx_vars\")\n  nt_features &lt;- model$other_vars$nt_features\n  set_size_var &lt;- model$other_vars$set_size\n  nt_distances &lt;- model$other_vars$nt_distances\n\n  # construct main brms formula from the bmm formula\n  formula &lt;- bmf2bf(model, formula) +\n    brms::lf(kappa2 ~ 1) +\n    brms::lf(mu2 ~ 1) +\n    brms::nlf(theta1 ~ log(exp(c) + exp(a))) +\n    brms::nlf(kappa1 ~ kappa) +\n    brms::nlf(expS ~ exp(s))\n\n  # additional internal terms for the mixture model formula\n  kappa_nts &lt;- paste0(\"kappa\", 3:(max_set_size + 1))\n  theta_nts &lt;- paste0(\"theta\", 3:(max_set_size + 1))\n  mu_nts &lt;- paste0(\"mu\", 3:(max_set_size + 1))\n\n  for (i in 1:(max_set_size - 1)) {\n    formula &lt;- formula +\n      glue_nlf(\"{kappa_nts[i]} ~ kappa\") +\n      glue_nlf(\"{theta_nts[i]} ~ {lure_idx[i]} * log(exp(c-expS*{nt_distances[i]}) + exp(a))\",\n               \"+ (1 - {lure_idx[i]}) * (-100)\") +\n      glue_nlf(\"{mu_nts[i]} ~ {nt_features[i]}\")\n  }\n\n  # define mixture family\n  formula$family &lt;- brms::mixture(brms::von_mises(\"tan_half\"),\n                                  brms::von_mises(\"identity\"),\n                                  nmix = c(1, max_set_size),\n                                  order = \"none\")\n\n  nlist(formula, data)\n}\nThe configure_model method should always take the arguments model, data, and formula (as a bmmformula) and return a named list with the formula (as a brmsformula) and the data. The brmsfamily should be stored within the formula.\nInside the configure_model method the brmsformula is generated using the bmf2bf function. This function converts the bmmformula passed to bmm() function into a brmsformula based on the information for the response variables provided in the bmmmodel object. There is a general method in R/bmmformula.R to construct the formula for all models with a single response variable.\n# default method to paste the full brms formula for all bmmodels\n#' @export\nbmf2bf.bmmodel &lt;- function(model, formula) {\n  # check if the model has only one response variable and extract if TRUE\n  brms_formula &lt;- NextMethod(\"bmf2bf\")\n\n  # for each dependent parameter, check if it is used as a non-linear predictor of\n  # another parameter and add the corresponding brms function\n  for (pform in formula) {\n    if (is_nl(pform)) {\n      brms_formula &lt;- brms_formula + brms::nlf(pform)\n    } else {\n      brms_formula &lt;- brms_formula + brms::lf(pform)\n    }\n  }\n  brms_formula\n}\n\n# paste first line of the brms formula for all bmmodels with 1 response variable\n#' @export\nbmf2bf.default &lt;- function(model, formula){\n  # set base brms formula based on response\n  brms::bf(paste0(model$resp_vars[[1]], \"~ 1\"))\n}\nThe bmf2bf.bmmodel method initializes the conversion of the bmmformula to a brms_formula. The first step for this is to paste the first line of a brmsformula that includes the response as the dependent variable on the left-hand side. For models with a single response variable this is done in the bmf2bf.default method. For models with more than one response variable, you will have to provide a model specific method of bmf2bf.myModel to convert the bmmformula into the brmsformula . This conversion from a bmmformula object into a brmsformula object is done to avoid users having to specify complicated and long formulas or specifying all additional response information in the brmsformula themselves. For more detailed information on the use of additional response information in a brmsformula please see the brmsformula documentation.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Example model file</span>"
    ]
  },
  {
    "objectID": "example-model.html#the-signal-discrimination-model-sdm",
    "href": "example-model.html#the-signal-discrimination-model-sdm",
    "title": "4  Example model file",
    "section": "4.2 The Signal Discrimination Model (SDM)",
    "text": "4.2 The Signal Discrimination Model (SDM)\nThe SDM model is defined in the file R/model_sdm.R. The SDM model differs in the configuration compared to the IMM model, as it requires custom STAN code. Let’s go through the different parts. As before, we start with the model definition.\n\n4.2.1 Model definition\n.model_sdm &lt;- function(resp_error = NULL, links = NULL, version = \"simple\", call = NULL, ...) {\n  out &lt;- structure(\n    list(\n      resp_vars = nlist(resp_error),\n      other_vars = nlist(),\n      domain = 'Visual working memory',\n      task = 'Continuous reproduction',\n      name = 'Signal Discrimination Model (SDM) by Oberauer (2023)',\n      citation = glue(\n        'Oberauer, K. (2023). Measurement models for visual working memory - \\\\\n        A factorial model comparison. Psychological Review, 130(3), 841-852'\n      ),\n      version = version,\n      requirements = glue(\n        '- The response variable should be in radians and represent the angular \\\\\n        error relative to the target'\n      ),\n      parameters = list(\n        mu = glue('Location parameter of the SDM distribution (in radians; \\\\\n                  by default fixed internally to 0)'),\n        c = 'Memory strength parameter of the SDM distribution',\n        kappa = 'Precision parameter of the SDM distribution'\n      ),\n      links = list(\n        mu = 'tan_half',\n        c = 'log',\n        kappa = 'log'\n      ),\n      fixed_parameters = list(mu = 0),\n      default_priors = list(\n        mu = list(main = \"student_t(1, 0, 1)\"),\n        kappa = list(main = \"student_t(5, 1.75, 0.75)\", effects = \"normal(0, 1)\"),\n        c = list(main = \"student_t(5, 2, 0.75)\", effects = \"normal(0, 1)\")\n      ),\n      void_mu = FALSE\n    ),\n    class = c('bmmodel', 'circular', 'sdm', paste0(\"sdm_\", version)),\n    call = call\n  )\n  out$links[names(links)] &lt;- links\n  out\n}\nThe model definition is similar to the IMM model, but the SDM model only requires the user to specify the response error, but not additional variables such as non-target variables. The class is also different, as the SDM model is not a subclass of the IMM model. We’ll skip the alias for the SDM model, as it is similar for every model.\n\n\n4.2.2 check_data() methods\nThe SDM shares a class with other circular models, so most of the data checks are performed by check_data.circular method, defined in the general file R/helpers-data.R. The sdm however, samples much more quickly in Stan, if the data is sorted by the predictor variables, so we have the following custom data check method for the sdm:\n#' @export\ncheck_data.sdm &lt;- function(model, data, formula) {\n  # data sorted by predictors is necessary for speedy computation of normalizing constant\n  data &lt;- order_data_query(model, data, formula)\n  NextMethod(\"check_data\")\n}\n\n\n4.2.3 configure_model() methods\nThe configure_model method for the SDM model is different compared to the IMM model, as it requires custom STAN code. The method is defined as follows:\n#' @export\nconfigure_model.sdm &lt;- function(model, data, formula) {\n  # construct the family\n  # note - c has a log link, but I've coded it manually for computational efficiency\n  sdm_simple &lt;- brms::custom_family(\n    \"sdm_simple\",\n    dpars = c(\"mu\", \"c\", \"kappa\"),\n    links = c(\"tan_half\", \"identity\", \"log\"),\n    lb = c(NA, NA, NA),\n    ub = c(NA, NA, NA),\n    type = \"real\", loop = FALSE,\n    log_lik = log_lik_sdm_simple,\n    posterior_predict = posterior_predict_sdm_simple\n  )\n\n  # prepare initial stanvars to pass to brms, model formula and priors\n  sc_path &lt;- system.file(\"stan_chunks\", package = \"bmm\")\n  stan_funs &lt;- read_lines2(paste0(sc_path, \"/sdm_simple_funs.stan\"))\n  stan_tdata &lt;- read_lines2(paste0(sc_path, \"/sdm_simple_tdata.stan\"))\n  stan_likelihood &lt;- read_lines2(paste0(sc_path, \"/sdm_simple_likelihood.stan\"))\n  stanvars &lt;- brms::stanvar(scode = stan_funs, block = \"functions\") +\n    brms::stanvar(scode = stan_tdata, block = \"tdata\") +\n    brms::stanvar(scode = stan_likelihood, block = \"likelihood\", position = \"end\")\n\n  # construct main brms formula from the bmm formula\n  formula &lt;- bmf2bf(model, formula)\n  formula$family &lt;- sdm_simple\n\n  # set initial values to be sampled between [-1,1] to avoid extreme SDs that\n  # can cause the sampler to fail\n  init &lt;- 1\n\n  # return the list\n  nlist(formula, data, stanvars, init)\n}\nLines 5-14 use the brms::custom_family function to define a custom family for the SDM model. The dpars argument specifies the parameters of the model, and the links argument specifies the link functions for the parameters. For more information, see here\nLines 17-23 read the custom STAN code from the inst/stan_chunks directory. This has to be specified with the system.file() command to ensure that the code is found when the package is installed. The stanvars object is used to pass custom STAN code to the brms package. The stanvars object is a list of brms::stanvar objects, each of which contains the STAN code for a specific part of the model. There is a separate .stan file for each part of the STAN code, and each file is read into a separate brms::stanvar object.\nConverting the bmmformula to a brmsformula and collecting all arguments is done entirely using the bmf2bf method.\n\n\n4.2.4 Post-processing methods\nUnlike the imm model, the sdm model requires some special post-processing because of the way the link functions are coded. These methods are applied after the brmsfit object is returned, at the very end of the bmm() pipeline:\n#' @export\npostprocess_brm.sdm &lt;- function(model, fit, ...) {\n  # manually set link_c to \"log\" since I coded it manually\n  fit$family$link_c &lt;- \"log\"\n  fit$formula$family$link_c &lt;- \"log\"\n  fit\n}\n\n#' @export\nrevert_postprocess_brm.sdm &lt;- function(model, fit, ...) {\n  fit$family$link_c &lt;- \"identity\"\n  fit$formula$family$link_c &lt;- \"identity\"\n  fit\n}\nwe also have a couple of special functions for custom families in brms (see the log_likand posterior_predict argument in the call to brms::custom_familiy()), which allow other typical tools from brms such posterior_predict of bridgesampling to work:\nlog_lik_sdm_simple &lt;- function(i, prep) {\n  mu &lt;- brms::get_dpar(prep, \"mu\", i = i)\n  c &lt;- brms::get_dpar(prep, \"c\", i = i)\n  kappa &lt;- brms::get_dpar(prep, \"kappa\", i = i)\n  y &lt;- prep$data$Y[i]\n  dsdm(y, mu, c, kappa, log = T)\n}\n\nposterior_predict_sdm_simple &lt;- function(i, prep, ...) {\n  mu &lt;- brms::get_dpar(prep, \"mu\", i = i)\n  c &lt;- brms::get_dpar(prep, \"c\", i = i)\n  kappa &lt;- brms::get_dpar(prep, \"kappa\", i = i)\n  rsdm(length(mu), mu, c, kappa)\n}\nWe will now look at how to construct all these parts for a new model. Hint: you don’t have to do it manually, you can use the use_model_template() function to generate templates for your model.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Example model file</span>"
    ]
  },
  {
    "objectID": "add-new-model.html",
    "href": "add-new-model.html",
    "title": "5  Adding a new model",
    "section": "",
    "text": "Function use_model_template()",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Adding a new model</span>"
    ]
  },
  {
    "objectID": "add-new-model.html#example",
    "href": "add-new-model.html#example",
    "title": "5  Adding a new model",
    "section": "5.1 Example",
    "text": "5.1 Example\nLet’s add a new model called gcm. Let’s assume that you have tested the model in Stan and you have the Stan code ready. We want to define a custom family for the gcm model, and we want to define the following blocks: likelihood, functions (see ?brms::stanvar for an explanation of the blocks).\nFirst you set up your system and git environment as described in Section 1. Then you can run the following code from RStudio in the root directory of the bmm package:\nuse_model_template(\"gcm\", custom_family = TRUE, stanvar_blocks = c(\"likelihood\", \"functions\"))\nThis will create the file bmm_model_gcm.R in the R/ directory and the files gcm_likelihood.stan and gcm_functions.stan in the inst/stan_chunks/ directory. The function will also open the files in RStudio. You will see the following output in the console:\n• Modify 'inst/stan_chunks/gcm_likelihood.stan'\n• Modify 'inst/stan_chunks/gcm_functions.stan'\n• Modify 'R/model_gcm.R'\nNow you can fill the files with the appropriate code. The Stan files will be empty, but the R file will have the following structure:\n#############################################################################!\n# MODELS                                                                 ####\n#############################################################################!\n# see file 'R/model_mixture3p.R' for an example\n\n.model_gcm &lt;- function(resp_var1 = NULL, required_arg1 = NULL, required_arg2 = NULL, links = NULL, version = NULL, call = NULL, ...) {\n   out &lt;- structure(\n     list(\n       resp_vars = nlist(resp_var1),\n       other_vars = nlist(required_arg1, required_arg2),\n       domain = '',\n       task = '',\n       name = '',\n       citation = '',\n       version = version,\n       requirements = '',\n       parameters = list(),\n       links = list(),\n       fixed_parameters = list(),\n       default_priors = list(par1 = list(), par2 = list()),\n       void_mu = FALSE\n     ),\n     class = c('bmmodel', 'gcm'),\n     call = call\n   )\n   if(!is.null(version)) class(out) &lt;- c(class(out), paste0(\"gcm_\",version))\n   out$links[names(links)] &lt;- links\n   out\n}\n# user facing alias\n# information in the title and details sections will be filled in\n# automatically based on the information in the .model_gcm()$info\n \n#' @title `r .model_gcm()$name`\n#' @name Model Name#' @details `r model_info(.model_gcm())`\n#' @param resp_var1 A description of the response variable\n#' @param required_arg1 A description of the required argument\n#' @param required_arg2 A description of the required argument\n#' @param links A list of links for the parameters.\n#' @param version A character label for the version of the model. Can be empty or NULL if there is only one version. \n#' @param ... used internally for testing, ignore it\n#' @return An object of class `bmmodel`\n#' @export\n#' @examples\n#' \\dontrun{\n#' # put a full example here (see 'R/model_mixture3p.R' for an example)\n#' }\ngcm &lt;- function(resp_var1, required_arg1, required_arg2, links = NULL, version = NULL, ...) {\n   call &lt;- match.call()\n   stop_missing_args()\n   .model_gcm(resp_var1 = resp_var1, required_arg1 = required_arg1, required_arg2 = required_arg2,\n                links = links, version = version,call = call, ...)\n}\n\n\n#############################################################################!\n# CHECK_DATA S3 methods                                                  ####\n#############################################################################!\n# A check_data.* function should be defined for each class of the model.\n# If a model shares methods with other models, the shared methods should be\n# defined in helpers-data.R. Put here only the methods that are specific to\n# the model. See ?check_data for details.\n# (YOU CAN DELETE THIS SECTION IF YOU DO NOT REQUIRE ADDITIONAL DATA CHECKS)\n\n#' @export\ncheck_data.gcm &lt;- function(model, data, formula) {\n   # retrieve required arguments\n   required_arg1 &lt;- model$other_vars$required_arg1\n   required_arg2 &lt;- model$other_vars$required_arg2\n\n   # check the data (required)\n\n   # compute any necessary transformations (optional)\n\n   # save some variables as attributes of the data for later use (optional)\n\n   NextMethod('check_data')\n}\n\n\n#############################################################################!\n# Convert bmmformula to brmsformla methods                               ####\n#############################################################################!\n# A bmf2bf.* function should be defined if the default method for consructing\n# the brmsformula from the bmmformula does not apply (e.g if aterms are required).\n# The shared method for all `bmmodels` is defined in bmmformula.R.\n# See ?bmf2bf for details.\n# (YOU CAN DELETE THIS SECTION IF YOUR MODEL USES A STANDARD FORMULA WITH 1 RESPONSE VARIABLE)\n\n#' @export\nbmf2bf.gcm &lt;- function(model, formula) {\n   # retrieve required response arguments\n   resp_var1 &lt;- model$resp_vars$resp_var1\n   resp_var2 &lt;- model$resp_vars$resp_arg2\n\n   # set the base brmsformula based \n   brms_formula &lt;- brms::bf(paste0(resp_var1,\" | \", vreal(resp_var2), \" ~ 1\" ),)\n\n   # return the brms_formula to add the remaining bmmformulas to it.\n   brms_formula\n}\n\n\n#############################################################################!\n# CONFIGURE_MODEL S3 METHODS                                             ####\n#############################################################################!\n# Each model should have a corresponding configure_model.* function. See\n# ?configure_model for more information.\n\n#' @export\nconfigure_model.gcm &lt;- function(model, data, formula) {\n   # retrieve required arguments\n   required_arg1 &lt;- model$other_vars$required_arg1\n   required_arg2 &lt;- model$other_vars$required_arg2\n\n   # retrieve arguments from the data check\n   my_precomputed_var &lt;- attr(data, 'my_precomputed_var')\n\n   # construct brms formula from the bmm formula\n   formula &lt;- bmf2bf(model, formula)\n\n   # construct the family & add to formula object \n   gcm_family &lt;- brms::custom_family(\n     'gcm',\n     dpars = c(),\n     links = c(),\n     lb = c(), # upper bounds for parameters\n     ub = c(), # lower bounds for parameters\n     type = '', # real for continous dv, int for discrete dv\n     loop = TRUE, # is the likelihood vectorized\n   )\n   formula$family &lt;- gcm_family\n\n   # prepare initial stanvars to pass to brms, model formula and priors\n   sc_path &lt;- system.file('stan_chunks', package='bmm')\n   stan_likelihood &lt;- read_lines2(paste0(sc_path, '/gcm_likelihood.stan'))\n   stan_functions &lt;- read_lines2(paste0(sc_path, '/gcm_functions.stan'))\n\n   stanvars &lt;- stanvar(scode = stan_likelihood, block = 'likelihood') +\n      stanvar(scode = stan_functions, block = 'functions')\n\n   # return the list\n   nlist(formula, data, stanvars)\n}\n\n\n#############################################################################!\n# POSTPROCESS METHODS                                                    ####\n#############################################################################!\n# A postprocess_brm.* function should be defined for the model class. See \n# ?postprocess_brm for details\n\n#' @export\npostprocess_brm.gcm &lt;- function(model, fit) {\n   # any required postprocessing (if none, delete this section)\n   fit\n}\nNow you have to:\n\nFill the .model_gcm function with the appropriate code. This function should return a list with all the variables specified above. The class of the list should be c('bmmmodel', 'gcm'). Rename the response arguments and the other required arguments, or delete the other arguments if you do not have any. You can see an example in the model_sdm.R file. Specify the parameters of the model, the link functions, what if any parameters are fixed (and to what value). It’s crucial that you set default priors for every parameter of the model, which should be informed by knowledge in the field.\nAdjust the user-facing alias. Here you should only rename the required arguments and fill in the @examples section with a full example. Everything else will be filled in automatically based on the information in the .model_gcm function.\nFill the check_data.gcm function with the appropriate code. This function should check the data and return the data. You may or may not need to compute any transformations or save some variables as attributes of the data.\nIf necessary define the bmf2bf.gcm method to convert the bmmformula to a brmsformula. The first step for this is always to specify the response variable and additional response information. Keep in mind that brms automatically interprets this formula as the linear model formula for the mu parameter of your custom family. Currently, brms requires all custom families to have a mu parameter. However, we recommend to code this parameter as a void_mu, and fix the intercept of this parameter to zero using constant priors. This way, the bmmformula can be used to only specify the linear or non-linear model for the parameters of a bmmmodel. If your model has a single response variable, you can delete this section.\nFill the configure_model.gcm function with the appropriate code. This function should construct the formula, the family, the stanvars. You can also retrieve any arguments you saved from the data check. Depending on your model, some of these parts might not be necessary. For example, for the mixture models (e.g. mixture3p), we construct a new formula, because we want to rename the arguments to make it easier for the user. For the sdmSimple model, we define the family ourselves, so we don’t need to change the formula.\nYou need to fill information about your custom family, and then fill the STAN files with your STAN code. Conveniently, you don’t have to edit lines 134-140: loading the STAN files and setting up the stanvars is set up automatically when calling the use_model_template function. Should you need to add more STAN files after you created the template, you can add the files in init/stan_chunks/ manually and edit those lines to additionally load the manually added files.\nFill the postprocess_brm.gcm function with the appropriate code. By post-processing, we mean changes to the fitted brms model - like renaming parameters, etc. If you don’t need any post-processing, you can delete this section.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Adding a new model</span>"
    ]
  },
  {
    "objectID": "add-new-model.html#testing",
    "href": "add-new-model.html#testing",
    "title": "5  Adding a new model",
    "section": "5.2 Testing",
    "text": "5.2 Testing\nUnit testing is extremely important. You should test your model with the testthat package. You can use the use_test() function to create a test file for your model. See file tests/testthat/test-bmm.R for an example of how we test the existing models. BRMS models take a long time to fit, so we don’t test the actual fitting process. The bmm() function provides an argument backend=\"mock\", which will return a mock object instead of fitting the model. This ensures that the entire pipeline works without errors. For example, here’s a test of the IMMfull model:\ntest_that('Available mock models run without errors',{\n  withr::local_options('bmm.silent'=2)\n  skip_on_cran()\n  dat &lt;- data.frame(\n    resp_err = rIMM(n = 5),\n    Item2_rel = 2,\n    Item3_rel = -1.5,\n    spaD2 = 0.5,\n    spaD3 = 2\n  )\n\n  # two-parameter model mock fit\n  f &lt;- bmmformula(kappa ~ 1, c ~ 1, a ~ 1, s ~ 1)\n  mock_fit &lt;- bmm(f, dat, \n                  imm(resp_err = \"resp_err\", \n                      setsize = 3, \n                      nt_features = paste0('Item',2:3,'_rel'), \n                      nt_distance=paste0('spaD',2:3)), \n                  backend = \"mock\", mock_fit = 1, rename=FALSE)\n  expect_equal(mock_fit$fit, 1)\n  expect_type(mock_fit$bmm$fit_args, \"list\")\n  expect_equal(names(mock_fit$fit_args[1:4]), c(\"formula\", \"data\"))\n})\nThe tests based on the testthat package are run every time you call the check() command. Before you submit your changes, make sure that all tests pass.\n\n\n\n\n\n\nImportant\n\n\n\nAdditionally, you should perform a full test of the model by running it in a separate script and ensuring it gives meaningful results. At the very least, you should perform basic parameter recovery simulations for hyper-parameters (i.e. means and standard deviations) as well as subject-level parameters to give users an idea of how much data they need to adequately estimate the model.\nWe are in the process of establishing guidelines for that.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Adding a new model</span>"
    ]
  },
  {
    "objectID": "add-new-model.html#add-an-example-dataset",
    "href": "add-new-model.html#add-an-example-dataset",
    "title": "5  Adding a new model",
    "section": "5.3 Add an example dataset",
    "text": "5.3 Add an example dataset\nAll new models should come with an example dataset, that can be loaded by users and can be used in the examples section. This should be either:\n\nA new dataset that you add to the package\nA dataset that already exists in the package but that can be used with the new model\nA dataset that exists in another package that you can load with data() and use with the new model\n\nFor example, the vignettes for the mixture2p and mixture3p use an external dataset from the mixtur package that can be loaded with data('bays2009_full', package='mixtur'). The IMM models use a dataset included in the current package. For instructions on how to add a new dataset see here.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Adding a new model</span>"
    ]
  },
  {
    "objectID": "add-new-model.html#add-an-article",
    "href": "add-new-model.html#add-an-article",
    "title": "5  Adding a new model",
    "section": "5.4 Add an article",
    "text": "5.4 Add an article\nAll new models should come with an article that explains some basic information about the model and how to estimate it with bmm. You can use the use_article() function to create a new article. See here for more information. The articles will be published automatically on the package website under “Articles” when the pull request is approved. You can browse the source code for the existing articles in the vignettes/articles/ directory. You can see the published version of the existing vignettes here.\nAnd that’s it! You have added a new model to the bmm package. You can now submit your changes to the bmm package repository.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Adding a new model</span>"
    ]
  }
]