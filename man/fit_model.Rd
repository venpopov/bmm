% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fit_model.R
\name{fit_model}
\alias{fit_model}
\title{Fit Measurement Models using BRMS}
\usage{
fit_model(
  formula,
  data,
  model,
  prior = NULL,
  chains = 4,
  parallel = getOption("bmm.parallel", FALSE),
  sort_data = getOption("bmm.sort_data", "check"),
  silent = getOption("bmm.silent", 1),
  checkpoint_every = NULL,
  stop_after = NULL,
  checkpoints_folder = "cp_folder",
  reset = FALSE,
  ...
)
}
\arguments{
\item{formula}{An object of class \code{bmmformula}. A symbolic description of the
model to be fitted.}

\item{data}{An object of class data.frame, containing data of all variables
used in the model. The names of the variables must match the variable names
passed to the \code{bmmmodel} object for required argurments.}

\item{model}{A description of the model to be fitted. This is a call to a
\code{bmmmodel} such as \code{mixture3p()} function. Every model function has a
number of required arguments which need to be specified within the function
call. Call \code{\link[=supported_models]{supported_models()}} to see the list of supported models and
their required arguments}

\item{prior}{One or more \code{brmsprior} objects created by \code{\link[brms:set_prior]{brms::set_prior()}}
or related functions and combined using the c method or the + operator. See
also \code{\link[=get_model_prior]{get_model_prior()}} for more help. Not necessary for the default model
fitting, but you can provide prior constraints to model parameters}

\item{chains}{Numeric. Number of Markov chains (defaults to 4)}

\item{parallel}{Logical; If TRUE, the number of cores on your machine will be
detected and brms will fit max(chains, cores) number of chains (specified
by the \code{chain} argument) in parallel using the parallel package}

\item{sort_data}{Logical. If TRUE, the data will be sorted by the predictor
variables for faster sampling. If FALSE, the data will not be sorted, but
sampling will be slower. If "check" (the default), \code{fit_model()} will check if
the data is sorted, and ask you via a console prompt if it should be
sorted. You can set the default value for this option using global
\verb{options(bmm.sort_data = TRUE/FALSE/"check)})\verb{or via}bmm_options(sort_data)`}

\item{silent}{Verbosity level between 0 and 2. If 1 (the default), most of
the informational messages of compiler and sampler are suppressed. If 2,
even more messages are suppressed. The actual sampling progress is still
printed. Set refresh = 0 to turn this off as well. If using backend =
"rstan" you can also set open_progress = FALSE to prevent opening
additional progress bars.}

\item{checkpoint_every}{Experimental. The number of iterations per checkpoint
at which to save intermediary sampling results. Note that \code{iter} is
divided by \code{checkpoint_every} to determine the number of checkpoints.
This must result in an integer (if not, there will be an error). This
option uses the \link[chkptstanr:chkptstanr-package]{chkptstanr} package to
allow interrupted sampling to be resumed. Disabled by default. Enabling
this option requires the \link[chkptstanr:chkptstanr-package]{chkptstanr}
package to be installed (see details).}

\item{stop_after}{Experimental. (positive integer). If checkpoint_every is
not NULL, this specifies the number of iterations to sample before
stopping. If \code{NULL}, then all iterations are sampled (defaults to
\code{NULL}). Note that sampling will stop at the end of the fir
stcheckpoint which has an iteration number greater than or equal to
\code{stop_after}.}

\item{checkpoints_folder}{If checkpoint_every is not NULL, this argument
specifies the directory where the checkpoints will be saved. Default is
'cp_folder' in the current working directory. Can be a relative or absolute
path.}

\item{reset}{Experimental. (logical). If checkpoint_every is not NULL, reset
= TRUE specifies to reset the checkpoints to 0 and restart sampling without
recompiling the model. If reset = FALSE, the sampling will resume from the
last checkpoint. Default is FALSE.}

\item{...}{Further arguments passed to \code{\link[brms:brm]{brms::brm()}}, Stan or chkptstanr. See
the description of \code{\link[brms:brm]{brms::brm()}} for more details}
}
\value{
An object of class brmsfit which contains the posterior draws along
with many other useful information about the model. Use methods(class =
"brmsfit") for an overview on available methods.
}
\description{
Fit a Bayesian multilevel measurement model. Currently
implemented are the two-parameter mixture model by Zhang and Luck (2008),
the three-parameter mixture model by Bays et al (2009), and three different
versions of the Interference Measurement Model (Oberauer et al., 2017).
This is a wrapper function for \link[brms:brm]{brms::brm}, which is used to estimate the
model.
}
\details{
The following models are supported:
\itemize{
\item IMMabc(resp_err, nt_features, setsize, regex)
\item IMMbsc(resp_err, nt_features, nt_distances, setsize, regex)
\item IMMfull(resp_err, nt_features, nt_distances, setsize, regex)
\item mixture2p(resp_err)
\item mixture3p(resp_err, nt_features, setsize, regex)
\item sdmSimple(resp_err)
}

Type  ?modelname  to get information about a specific model, e.g.  ?IMMfull

Type \code{help(package=bmm)} for a full list of available help topics.
\subsection{Using checkpoints}{

The \code{checkpoint_every} argument allows you to save the current state of the
sampler at specific iteration numbers. This can be useful if you want to
interrupt the sampling process and resume it later. This feature requires
the chkptstanr package to be installed, and to use "backend = cmdstanr".
The current CRAN version of chkptstanr has a bug that prevents it from
working. Until the issue is fixed, you can install a working forked version
of chkptstanr with:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{remotes::install_github("venpopov/chkptstanr")
}\if{html}{\out{</div>}}
}
}
\examples{
\dontrun{
# generate artificial data from the Signal Discrimination Model
dat <- data.frame(y=rsdm(n=2000))

# define formula
ff <- bmmformula(c ~ 1,
                 kappa ~ 1)

# fit the model
fit <- fit_model(formula = ff,
                 data = dat,
                 model = sdmSimple(resp_err = "y"),
                 parallel=T,
                 iter=500,
                 backend='cmdstanr')


# Alternatively, fit the model via checkpointing - save the state of the
# sampler every 500 iterations # and stop it after 2000 iterations to check the
# results (Experimental feature)
remotes::install_github("venpopov/chkptstanr")
library(chkptstanr)

fit <- fit_model(formula = ff,
                data = dat,
                model = sdmSimple(resp_err = "y"),
                parallel=T,
                backend='cmdstanr',
                warmup = 1000,
                iter = 4000,
                checkpoint_every = 500,
                stop_after = 2000,
                checkpoints_folder = 'checkpoints/sdm_fit1')

# The output will look like this:

# > Sampling will stop after checkpoint 4
# > Model executable is up to date!
# >   Initial Warmup (Typical Set)
# > Chkpt: 1 / 8; Iteration: 500 / 4000 (warmup)
# > Chkpt: 2 / 8; Iteration: 1000 / 4000 (warmup)
# > Chkpt: 3 / 8; Iteration: 1500 / 4000 (sample)
# > Chkpt: 4 / 8; Iteration: 2000 / 4000 (sample)
# > Stopping after 4 checkpoints

# The intermediate results are saved to the fit object:
summary(fit)

# You can also resume the sampling from the last checkpoint, as long as you
# don't change the arguments to fit_model():

fit2 <- fit_model(formula = ff,
                data = dat,
                model = sdmSimple(resp_err = "y"),
                parallel=T,
                backend='cmdstanr',
                warmup = 1000,
                iter = 4000,
                checkpoint_every = 500,
                stop_after = 2000,
                checkpoints_folder = 'checkpoints/sdm_fit1')

}

}
\references{
Frischkorn, G. T., & Popov, V. (2023). A tutorial for estimating
mixture models for visual working memory tasks in brms: Introducing the
Bayesian Measurement Modeling  (bmm) package for R.
https://doi.org/10.31234/osf.io/umt57
}
\seealso{
\code{\link[=supported_models]{supported_models()}}, \code{\link[brms:brm]{brms::brm()}}
}
